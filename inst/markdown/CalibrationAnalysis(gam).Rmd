---
title: "Calibration Analysis"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
  rmarkdown::html_document:
    theme: united
    highlight: tango
    toc: true
    number_sections: true
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import of Data

We import the data and select the variables needed for the analysis.
```{r}
load(paste0(PATH.OUT, "/", FILENAME, "Data.RData"))
tmp <- strsplit(FORMULA, "~")[[1]]
y.var <- names(unlist(sapply(colnames(CalibrationData), 
                             grep, x = tmp[1])))
x.vars <- names(unlist(sapply(colnames(CalibrationData), 
                              grep, x = tmp[2])))
if(SUBSET != ""){
  calData <- eval(call("subset", x =  CalibrationData,
                       subset = parse(text = SUBSET)))
}else{
  calData <- CalibrationData
}
calData <- calData[,c(y.var, x.vars)]
calData
```

# Model

We will apply the following model.
```{r}
FORMULA
```

# Analysis

We now fit generalized additive model.
```{r}
fit <- gam(as.formula(FORMULA), data = calData)
summary(fit)
```

We compute needed parameters for the analysis.
```{r}
N <- 100
ab <- coef(fit)
names(ab) <- NULL
conc <- seq(from = 0, to = max(calData[,concVar]), len = N)
newDF <- data.frame(conc = conc)
names(newDF) <- concVar
resp <- predict(fit, newdata = newDF)
names(resp) <- NULL
predFunc <- function(newdata){}
body(predFunc) <- substitute({ Y <- with(newdata, eval(y))
fun <- splinefun(x = resp, y = conc, method = "monoH.FC")
fun(Y) }, list(y = parse(text = respVar),
               resp = resp,
               conc = conc))

y0 <- predict(fit, newdata = newDF[1,,drop = FALSE], se = TRUE)
fun <- splinefun(x = resp, y = conc, method = "monoH.FC")
```

We plot the given concentrations against the fitted values.
```{r}
library(ggplot2)
modelPlot <- ggplot(calData, aes_string(x = concVar, y = respVar)) +
                geom_point() + geom_smooth(method = "gam", formula = y ~ s(x, k = k))
modelPlot
```

# Computation of LOB, LOD and LOQ

We compute limit of blank (LOB), limit of detection (LOD) and limit of 
quantification (LOQ) using the linear regression fit. We get the LOB as the
upper bound of the one-sided 95\% confidence interval of the intercept. Based
on the LOB and the standard error of the residuals, we compute LOD and 
finally LOQ based on LOD.
```{r}
LOB <- fun(1.645*y0$se.fit)
names(LOB) <- "LOB"
LOB
LOD <- fun(3.3*y0$se.fit)
names(LOD) <- "LOD"
LOD
LOQ <- 3*LOD
names(LOB) <- "LOQ"
LOQ
```

# Save Results

We save the results.
```{r}
save(fit, LOB, LOD, LOQ, file = paste0(PATH.OUT, "/", FILENAME, "Results.RData"))
```

# Save Model
```{r}
saveRDS(object = predFunc, file = paste0(PATH.OUT, "/", FILENAME, "Model.rds"))
```

# Software

```{r}
sessionInfo()
```

